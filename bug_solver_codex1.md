## Solver module review (2024-06-08)
- **High – israel_stewart/solvers/finite_difference.py:299**: `_compute_conservative_derivative` slices `slice(self.ghost_points, -self.ghost_points)` from a flux difference array that is already shorter than the interior, so the returned derivative drops two interior cells per axis. The resulting gradients are the wrong shape and systematically suppress edge dynamics. *Hint:* reshape the flux evaluation so that the difference has the same length as the original field (e.g., build interface fluxes with `n+1` entries and index the interior explicitly) instead of slicing away additional points.
- **High – israel_stewart/solvers/finite_difference.py:330-338**: `_compute_numerical_flux` warns and returns zeros for offsets ±1.5, yet the 4th-order path calls those offsets. All fourth-order derivatives therefore collapse to second-order with zero far-flux contributions. *Hint:* implement the higher-order interface stencils (or refuse `order=4`) so the requested flux samples are actually computed.
- **High – israel_stewart/solvers/finite_difference.py:353-359,535-539**: The stencil slicing uses `None` as the stop for non-negative offsets. For offsets 0,+1,+2 this pulls arrays longer than the physical domain, so the accumulations raise shape errors (or silently misalign when broadcasting). *Hint:* clamp the stop index to `-self.ghost_points + offset` for *all* offsets (and do the same in the WENO reconstruction) so every slice matches the target field shape.
- **High – israel_stewart/solvers/finite_difference.py:383-391**: `compute_divergence` fixes the μ index to `component_indices[0]` and uses the spatial loop index as ν, so it differentiates the wrong tensor components (`∂_i T^{μ i}` instead of `∂_i T^{i ν}`). *Hint:* set the component slice to `[dim + 1, component_indices[0]]` (or unpack `(mu, nu)` properly) when forming the slice before calling `_compute_conservative_derivative`.
- **High – israel_stewart/solvers/implicit.py:848-883**: `_compute_relaxation_jacobian` starts writing relaxation blocks at index 0, overwriting the conserved (ρ,n,uμ) entries because it never skips those offsets. The Newton update therefore damps the wrong variables. *Hint:* compute the flat offsets with the same ordering as `to_state_vector()`—skip the conserved chunks before writing Π, π, q blocks or build the Jacobian via slice views tied to that ordering.
- **High – israel_stewart/solvers/spectral.py:135-154**: Derivative caching keys by `id(field)` without invalidation. In-place updates reuse the same id, so you can return stale gradients, and every new view (e.g. `T[...,0,i]`) adds a never-cleared entry—eventually leaking memory. *Hint:* drop the cache or add an explicit invalidation/weakref strategy keyed on immutable data (hash/version) and clear it each timestep.
- **High – israel_stewart/solvers/spectral.py:655-763**: `ConservationLaws.evolution_equations()` supplies `dmom_dt`, but `_apply_explicit_update` only looks for `du_dt` and `_ensure_complete_rhs` fills zeros, so momentum is never advanced. *Hint:* translate `dmom_dt` into an update for `u_mu` (or accept the key directly) before zero-filling so the explicit step evolves the flow.
